#include <LiquidCrystal.h>

/*/ --- Inital Notes --- //

Plot:

- set in a fantasty world where the various fantasy races (elves, dwarves, humans, etc) work and live with fantasty creatures 
- for this game, the creature are griffins, phoenixes, and dragons
- i'm imaginging a big fantasy city as the setting for this particular game
- basic premise: you're providing care to a child/baby creature while their parents are working
- game inspired by tamagotchis
- there are wellness levels (hunger, thist, etc) for the creature you're caring for
- there is a trust system that gradually increases as you care for the creature

Code:

- using F Macros where possible because the project originally exceed the Arduino's RAM limit
- F() to store strings in flash memory instead of RAM
- using it with lcd.print(), serial.print(), and serial.println()
- slightly slower access but conserves on RAM space

- using character arrays instead of strings because unpredicable string behaviour kept giving me gibberish in the serial */

// Breadboard Parameters //

// values for LCD
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

// values for buttons
int button1 = A1;
int button2 = A2;
int button3 = A3;
int button4 = A4;
int button5 = A5;
int button6 = 7;
int button7 = 8;

// values for RGB light
int RGBRedPin = 9;
int RGBBluePin = 10;
int RGBGreenPin = 6;

// --- Functions: Test Board Inputs --- //

/*
void button1press() // validated
{
  if (digitalRead(button1) == HIGH)
  {
    Serial.println(F("We pressed button 1."));
    delay(100);
  }
}

void button2press() // validated
{
  if (digitalRead(button2) == HIGH)
  {
    Serial.println(F("We pressed button 2."));
    delay(100);
  }
}

void button3press() // validated
{
  if (digitalRead(button3) == HIGH)
  {
    Serial.println(F("We pressed button 3."));
    delay(100);
  }
}

void button4press() // validated
{
  if (digitalRead(button4) == HIGH)
  {
    Serial.println(F("We pressed button 4."));
    delay(100);
  }
}

void button5press() // validated
{
  if (digitalRead(button5) == HIGH)
  {
    Serial.println(F("We pressed button 5."));
    delay(100);
  }
}

void button6press() // validated
{
  if (digitalRead(button6) == HIGH)
  {
    Serial.println(F("We pressed button 6."));
    delay(100);
  }
}

void RGBTest()
{ // validated
  digitalWrite(RGBRedPin, HIGH);
  delay(300);
  digitalWrite(RGBRedPin, LOW);
  digitalWrite(RGBGreenPin, HIGH);
  delay(300);
  digitalWrite(RGBGreenPin, LOW);
  digitalWrite(RGBBluePin, HIGH);
  delay(300);
  digitalWrite(RGBBluePin, LOW);
}

// LCD validated via setup() */

// --- Name, Species and Job Arrays --- //

const char *species[] = {"Griffin", "Dragon", "Phoenix"};
const char *namesGriffin[] = {"Talonclaw", "Stormcloud", "Windrider", "Thundercloud", "Moonbeak", "Mistwing", "Stormrider"};
const char *namesDragon[] = {"Silverclaw", "Stoneblade", "Frostmaw", "Tempest", "Cloudrend", "Stormshower", "Skyrender"};
const char *namesPhoenix[] = {"Fireheart", "Emberflare", "Dawnwing", "Ashfeather", "Stormcinder", "Flamewing", "Cindersoar"};
const char *parentJobs[] = {"guarding the city", "hunting", "providing transportation", "teaching", "building infrastructure", "conducting city repairs", "meeting with delegates", "holding council"};
const char *tiredness[] = {"very tired", "somewhat tired", "well rested"};
const char *hunger[] = {"very hungry", "somewhat hungry", "well-fed"};
const char *thirst[] = {"very thirsty", "somewhat thirsty", "well-hydrated"};
const char *happiness[] = {"somewhat unhappy", "happy", "very happy"};
const char *trust[] = {"barely at all", "just a tiny bit", "a little bit", "a fair bit", "quite a lot", "completely"};

// --- Ongoing Values --- //

// initialize nickname-related inputs as char arrays with limit of 20 indexes
char currentNickname[20] = "";
char nicknameInput[20] = "";

// intialize care levels as const char arrays (user does not input these values)
const char *currentName = "";
const char *currentSpecies = "";
const char *job1 = "";
const char *job2 = "";
const char *currentTiredness = "";
const char *currentHunger = "";
const char *currentThirst = "";
const char *currentHappiness = "";
const char *currentTrust = "";

// intialize creature age to 0
// intialize index values (which will be used to generate random care levels by pulling misc values from related arrays) to 0
int currentAge = 0;

int speciesIndex = 0;
int griffinNameIndex = 0;
int dragonNameIndex = 0;
int phoenixNameIndex = 0;

int trustIndex = 0;
int job1Index = 0;
int job2Index = 0;
int tirednessIndex = 0;
int hungerIndex = 0;
int thirstIndex = 0;
int happinessIndex = 0;

bool isGenerated = false;

/* -- ASCII Art ---

functions to display creatures on LCD
Credit: ASCII Art functions generated by Deepseek and then further edited by me */

// - Griffin - //

void displayGriffin()
{
  lcd.clear();
  // Line 1: Eagle head and wings
  lcd.print(F(" {^v^}>> "));
  delay(10);
  // Line 2: Lion body
  lcd.setCursor(0, 1);
  lcd.print(F(" /\\_/\\~~~>"));
  delay(10);
}

void displaySleepingGriffin()
{
  lcd.clear();
  // Line 1: Sleeping eagle head and wings
  lcd.print(F(" {-v-}zz "));
  delay(10);
  // Line 2: Curled up lion body
  lcd.setCursor(0, 1);
  lcd.print(F(" ~\\_/~  "));
  delay(10);
}

void displayEatingGriffin()
{
  lcd.clear();
  // Line 1: Eagle head with food and wings
  lcd.print(F(" {^o^}>> "));
  delay(10);
  // Line 2: Lion body with food
  lcd.setCursor(0, 1);
  lcd.print(F(" /\\_/\\<~~>"));
  delay(10);
}

void displayPlayingGriffin()
{
  lcd.clear();
  // Line 1: Excited eagle head and wings
  lcd.print(F(" {^+^}>> "));
  delay(10);
  // Line 2: Pouncing lion body
  lcd.setCursor(0, 1);
  lcd.print(F(" /\\_/\\===~"));
  delay(10);
}

// - Dragon - //

void displayDragon()
{
  lcd.clear();
  // Line 1: Head and wings
  lcd.print(F(" /^..^\\ "));
  delay(10);
  // Line 2: Body and tail
  lcd.setCursor(0, 1);
  lcd.print(F(" \\_()_/--->"));
  delay(10);
}

void displaySleepingDragon()
{
  lcd.clear();
  // Line 1: Head tucked in, sleeping
  lcd.print(F("  (^-.-^)zz "));
  delay(10);
  // Line 2: Coiled body
  lcd.setCursor(0, 1);
  lcd.print(F(" ~\\_()_/~~"));
  delay(10);
}

void displayEatingDragon()
{
  lcd.clear();
  // Line 1: Head chewing
  lcd.print(F(" /^==^\\ "));
  delay(10);
  // Line 2: Body with food in mouth
  lcd.setCursor(0, 1);
  lcd.print(F(" \\_()_/==>"));
  delay(10);
}

void displayPlayingDragon()
{
  lcd.clear();
  // Line 1: Excited head, fire breath
  lcd.print(F(" /^+^\\~~~ "));
  delay(10);
  // Line 2: Running pose
  lcd.setCursor(0, 1);
  lcd.print(F(" \\_()_/===>>"));
  delay(10);
}

// - Phoenix - //

void displayPhoenix()
{
  lcd.clear();
  // Line 1: Head and flames
  lcd.print(F(" (^o^)>>"));
  delay(10);
  // Line 2: Fire trail
  lcd.setCursor(0, 1);
  lcd.print(F(" //_\\~~~~>"));
  delay(10);
}

void displaySleepingPhoenix()
{
  lcd.clear();
  // Line 1: Head resting, small embers
  lcd.print(F(" (-.-)~ "));
  delay(10);
  // Line 2: Coiled fire
  lcd.setCursor(0, 1);
  lcd.print(F(" //_\\~~zZ~>"));
  delay(10);
}

void displayEatingPhoenix()
{
  lcd.clear();
  // Line 1: Head nibbling
  lcd.print(F(" (^=^) "));
  delay(10);
  // Line 2: Fire trail with food sparks
  lcd.setCursor(0, 1);
  lcd.print(F(" //_\\~~o~>"));
  delay(10);
}

void displayPlayingPhoenix()
{
  lcd.clear();
  // Line 1: Excited head, roaring fire
  lcd.print(F(" (^o^)===="));
  delay(10);
  // Line 2: Spiraling fire trail
  lcd.setCursor(0, 1);
  lcd.print(F("~\\~o~//>>"));
  delay(10);
}

// --- End ASCII Art --- //

// --- Functions --- //

// - Display Creatures - //

void displayCreature()
{
  // clear LCD, check which creature is currently enabled, and then display that creature (in its normal form)
  lcd.clear();

  // using strcmp; returns 0 if the strings being compared match
  if (strcmp(currentSpecies, "Griffin") == 0)
  {
    displayGriffin();
  }
  else if (strcmp(currentSpecies, "Dragon") == 0)
  {
    displayDragon();
  }
  else if (strcmp(currentSpecies, "Phoenix") == 0)
  {
    displayPhoenix();
  }
}

void displaySleepingCreature()
{
  // clear LCD, check which creature is currently enabled, and then display that creature (in its sleeping form)
  lcd.clear();

  if (strcmp(currentSpecies, "Griffin") == 0)
  {
    displaySleepingGriffin();
  }
  else if (strcmp(currentSpecies, "Dragon") == 0)
  {
    displaySleepingDragon();
  }
  else if (strcmp(currentSpecies, "Phoenix") == 0)
  {
    displaySleepingPhoenix();
  }
}

void displayEatingCreature()
// clear LCD, check which creature is currently enabled, and then display that creature (in its eating form)
{
  lcd.clear();

  if (strcmp(currentSpecies, "Griffin") == 0)
  {
    displayEatingGriffin();
  }
  else if (strcmp(currentSpecies, "Dragon") == 0)
  {
    displayEatingDragon();
  }
  else if (strcmp(currentSpecies, "Phoenix") == 0)
  {
    displayEatingPhoenix();
  }
}

void displayPlayingCreature()
// clear LCD, check which creature is currently enabled, and then display that creature (in its playing form)
{
  lcd.clear();

  if (strcmp(currentSpecies, "Griffin") == 0)
  {
    displayPlayingGriffin();
  }
  else if (strcmp(currentSpecies, "Dragon") == 0)
  {
    displayPlayingDragon();
  }
  else if (strcmp(currentSpecies, "Phoenix") == 0)
  {
    displayPlayingPhoenix();
  }
}

// - Creature Initialization - //

void nicknamePrompt()
{

  bool isValid = false;

  while (!isValid)

  {
    Serial.println(F("\nWould you like to give them a nickname?"));
    Serial.println(F("Enter 'Y' for yes or 'N' for no:"));
    // prompt for nickname input

    while (!Serial.available())
    {
      // do nothing while serial isn't available
      delay(10);
    }

    char nicknamePromptResponse = (char)Serial.read();
    // casts current serial byte to char; by default, serial byte is read as an int
    // intialize new character named nicknamePromptResponse
    // first byte in serial is assigned to nicknamePromptResponse
    // then we check if it's y/Y, n/N, or anything else, and provide the relevant int statement

    if (nicknamePromptResponse == 'Y' || nicknamePromptResponse == 'y')
    {
      Serial.print(F("What would you like to nickname "));
      Serial.print(currentName);
      Serial.println(F("?"));

      int i = 0;
      // intialize i to 0 for upcoming while loop
      memset(nicknameInput, 0, sizeof(nicknameInput));
      // use memset() to clear every byte in nicknameInput to 0; resets the array
      // memset() to set a block of memory to a certain value
      // use sizeof() to indicate how many bytes to fill

      while (!Serial.available())
      // don't do anything while serial isn't available
      {
        delay(10);
      }

      while (Serial.available() && i < sizeof(nicknameInput) - 1)
      {
        // while serial is available
        // and i does not exceed the length of nicknameInput (since it's a character array)
        // include negative 1 to account for the null terminator that properly ends the string
        // so user input can be length of array minus one; while loop will exit once it reaches that point

        nicknameInput[i++] = (char)Serial.read();
        // reads the char available in the serial buffer
        // (char) to cast that byte into a character
        // nicknameInput[i++] adds the character to the array on each loop, and increments the loop's i value by 1
        delay(200);
        // delay after each character is read; allows a bit of time for user to enter the next letter/character
      }
      nicknameInput[i] = '\0';
      // assigns current value of i (i.e. the index of the last spot in the current nicknameInput array) to a null terminator
      strncpy(currentNickname, nicknameInput, sizeof(currentNickname));
      // uses strncpy() to copy the value of nicknameInput into currentNickname
      // copies only up to the size of the the currentNickname array so it doesn't overflow destination array
      // learned the difference between strncpy and strcpy:
      // - strncpy limits the number of characters copied based on buffer size
      // - strcpy copies without any concern/any checks for the destination size, so could write past the end of the array
      currentNickname[sizeof(currentNickname) - 1] = '\0';
      // last safety step: if nicknameInput was somehow still too long, strncpy() might not edd the null nerminator
      // this forces the last character in the array to be a null terminator
      isValid = true;
      // exit the isValid while loop
    }

    else if (nicknamePromptResponse == 'N' || nicknamePromptResponse == 'n')
    {
      Serial.println(F("You're not choosing a nickname."));
      strncpy(currentNickname, currentName, sizeof(currentNickname));
      // copies the value of currentName into currentNickname
      // if the user doesn't give them a nickname, we want to use currentName as the currentNickname value
      currentNickname[sizeof(currentNickname) - 1] = '\0';
      isValid = true;
    }
    else
    {
      Serial.print(F("Invalid entry: "));
      Serial.println(nicknamePromptResponse);
      Serial.println(F("Please enter 'Y' or 'N'."));
    }
  }
}

void generateTraits()
{
  if (digitalRead(button1) == HIGH && (!isGenerated))
  {
    delay(1000);
    // delay because i don't want user to be able to press button more than once; only want to generate one creature

    isGenerated = true;

    speciesIndex = random(0, 3);
    currentSpecies = species[speciesIndex];
    // choose random value from array for current species value

    switch (speciesIndex)
    // choose random name for creature based on which creature we currently have
    {
    case 0:
      griffinNameIndex = random(0, 7);
      // assign random number the matches the array size
      currentName = namesGriffin[griffinNameIndex];
      // choose random name
      delay(50);
      break;

    case 1:
      dragonNameIndex = random(0, 7);
      currentName = namesDragon[dragonNameIndex];
      delay(50);
      break;

    case 2:
      phoenixNameIndex = random(0, 7);
      currentName = namesPhoenix[phoenixNameIndex];
      delay(50);
      break;
    }

    displayCreature();
    // display the current creature on the LCD

    // generate random values for currentAge, currentTiredness, currentHunger, currentThirst, currentTrust, and currentHappiness
    currentAge = random(2, 5);

    tirednessIndex = random(0, 3);
    currentTiredness = tiredness[tirednessIndex];

    hungerIndex = random(0, 3);
    currentHunger = hunger[hungerIndex];

    thirstIndex = random(0, 3);
    currentThirst = thirst[thirstIndex];

    trustIndex = random(0, 2);
    // only chooses from the first two trust levels in the array
    currentTrust = trust[trustIndex];

    happinessIndex = random(0, 3);
    currentHappiness = happiness[happinessIndex];

    // choose two random jobs for the parents
    // do while loop to ensure job1Index isn't the same as job2Index
    do
    {
      job1Index = random(0, 8);
      job2Index = random(0, 8);
    } while (job1Index == job2Index);

    job1 = parentJobs[job1Index];
    job2 = parentJobs[job2Index];

    // generate all the output to the serial
    Serial.println("\n");
    delay(100);
    Serial.print(F("You're providing care to a "));
    Serial.print(currentSpecies);
    delay(100);
    Serial.print(F(" whose name is "));
    Serial.print(currentName);
    Serial.println(F("."));
    delay(100);
    Serial.print(F("They are "));
    Serial.print(currentAge);
    Serial.print(F(" years old, "));
    delay(100);
    Serial.print(F("and they're currently "));
    Serial.print(currentTiredness);
    Serial.print(F(", "));
    Serial.print(currentThirst);
    Serial.print(F(", and "));
    Serial.print(currentHunger);
    Serial.println(F("."));
    delay(100);
    Serial.print(F("They trust you "));
    Serial.print(currentTrust);
    Serial.println(F("."));
    delay(100);
    Serial.print(F("Their parents are "));
    Serial.print(job1);
    Serial.print(F(" and "));
    Serial.print(job2);
    Serial.println(F("."));
    delay(100);
    // prompt for nickname
    nicknamePrompt();
  }
  else if (digitalRead(button1) == HIGH && (isGenerated))
  // the program shouldn't ever access this else if statement here, but putting it here as a failsafe in case i've missed something
  {
    delay(50);
    Serial.print(F("You're already caring for "));
    Serial.print(currentNickname);
    delay(500);
  }
}

// - Menu Options - //

void incrementTrust()
{

  int currentLevel = -1;
  // intiailize currentLevel to -1
  for (int i = 0; i < 6; i++)
  // loop six times
  {
    if (strcmp(currentTrust, trust[i]) == 0)
    // check on each loop if currenttrust and trust array value are the same
    {
      currentLevel = i;
      // if they're the same, assign the current level to i and then break loop
      break;
    }
  }

  if (currentLevel >= 0 && currentLevel < 5)
  // check if current level is equal to or greater than 0, and less than five
  // i.e. it doesn't equal the last index in the trust array
  {
    currentTrust = trust[currentLevel + 1];
    // if currentTrust isn't already at the highest index in the array, add 1, so currentTrust value moves up one in the array
  }
}

void danceParty()
// cycle through RGBs and then increment trust level
{
  displayPlayingCreature();
  // display playing variation
  Serial.print(F("\n"));
  Serial.print(F("You and "));
  Serial.print(currentNickname);
  Serial.print(F(" have a little dance party."));

  digitalWrite(RGBRedPin, HIGH);
  delay(300);
  digitalWrite(RGBRedPin, LOW);
  digitalWrite(RGBGreenPin, HIGH);
  delay(300);
  digitalWrite(RGBGreenPin, LOW);
  digitalWrite(RGBBluePin, HIGH);
  delay(300);
  digitalWrite(RGBBluePin, LOW);

  digitalWrite(RGBRedPin, HIGH);
  delay(300);
  digitalWrite(RGBRedPin, LOW);
  digitalWrite(RGBGreenPin, HIGH);
  delay(300);
  digitalWrite(RGBGreenPin, LOW);
  digitalWrite(RGBBluePin, HIGH);
  delay(300);
  digitalWrite(RGBBluePin, LOW);

  digitalWrite(RGBRedPin, HIGH);
  delay(300);
  digitalWrite(RGBRedPin, LOW);
  digitalWrite(RGBGreenPin, HIGH);
  delay(300);
  digitalWrite(RGBGreenPin, LOW);
  digitalWrite(RGBBluePin, HIGH);
  delay(300);
  digitalWrite(RGBBluePin, LOW);

  digitalWrite(RGBRedPin, HIGH);
  delay(300);
  digitalWrite(RGBRedPin, LOW);
  digitalWrite(RGBGreenPin, HIGH);
  delay(300);
  digitalWrite(RGBGreenPin, LOW);
  digitalWrite(RGBBluePin, HIGH);
  delay(300);
  digitalWrite(RGBBluePin, LOW);

  incrementTrust();
  // incremement trust
}

void foodAndWater()
{
  // display eating creature
  // check thirst and hunger values; increment if they're not at the top of their arrays
  // then increment trust
  Serial.print(F("\n"));
  Serial.print(F("You give some food and water to "));
  Serial.print(currentNickname);
  Serial.println(F("."));
  delay(1000);
  displayEatingCreature();

  int currentIndexHunger = -1;
  // same process as checking for currentTrust value earlier
  // do the same for currentHunger and currentThirst
  for (int i = 0; i < 3; i++)
  {
    if (strcmp(currentHunger, hunger[i]) == 0)
    {
      currentIndexHunger = i;
      break;
    }
  }

  int currentIndexThirst = -1;
  for (int i = 0; i < 3; i++)
  {
    if (strcmp(currentThirst, thirst[i]) == 0)
    {
      currentIndexThirst = i;
      break;
    }
  }

  // if currentHunger and currentThirst aren't at their highest array values, increment by one array value
  // else just print current values
  if (currentIndexHunger < 2)
  {
    currentHunger = hunger[currentIndexHunger + 1];
    Serial.print(currentNickname);
    Serial.print(F(" is now "));
    Serial.print(currentHunger);
    Serial.println(F("."));
  }
  else
  {
    Serial.print(currentNickname);
    Serial.print(F(" is "));
    Serial.print(currentHunger);
    Serial.println(F("."));
  }

  if (currentIndexThirst < 2)
  {
    currentThirst = thirst[currentIndexThirst + 1];
    Serial.print(currentNickname);
    Serial.print(F(" is now "));
    Serial.print(currentThirst);
    Serial.println(F("."));
  }
  else
  {
    Serial.print(currentNickname);
    Serial.print(F(" is "));
    Serial.print(currentThirst);
    Serial.println(F("."));
  }
  incrementTrust();
  // finally, increment trust
  delay(2000);
}

void nap()
// same functionality as foodAndWater() but for tiredness level
{
  Serial.print(F("\n"));
  Serial.print(F("You tuck "));
  Serial.print(currentNickname);
  Serial.println(F(" in for a nap."));
  delay(1000);
  displaySleepingCreature();

  int currentIndexNap = -1;
  for (int i = 0; i < 3; i++)
  {
    if (strcmp(currentTiredness, tiredness[i]) == 0)
    {
      currentIndexNap = i;
      break;
    }
  }

  if (currentIndexNap < 2)
  {
    currentTiredness = tiredness[currentIndexNap + 1];
    Serial.print(currentNickname);
    Serial.print(F(" is now "));
    Serial.print(currentTiredness);
    Serial.println(F("."));
  }
  else
  {
    Serial.print(currentNickname);
    Serial.print(F(" is "));
    Serial.print(currentTiredness);
    Serial.println(F("."));
  }
  incrementTrust();
  delay(2000);
}

void headpats()
{
  displayPlayingCreature();

  if (strcmp(currentTrust, trust[5]) != 0)
  // if current trust is anything except the last index in the trust array, we can't give headpats

  {
    Serial.print(currentNickname);
    Serial.println(F(" doesn't trust you enough yet for headpats."));
  }
  else
  {
    // if trust level is the highest it can be, we can give headpats
    Serial.print(F("\n"));
    Serial.print(F("You pat "));
    Serial.print(currentNickname);
    Serial.println(F(" on the head."));
  }

  delay(2000);
}

void displayCurrentCondition()
{
  // display all currentvalues
  Serial.print(F("\n"));
  Serial.print(currentNickname);
  Serial.print(F(" is currently "));
  Serial.print(currentTiredness);
  Serial.println(F("."));
  delay(400);
  Serial.print(F("They're "));
  Serial.print(currentThirst);
  Serial.print(F(" and they're "));
  Serial.print(currentHunger);
  Serial.println(F("."));
  delay(400);
  Serial.print(F("They trust you "));
  Serial.print(currentTrust);
  Serial.println(F("."));
  delay(2000);
}

void parentsPickup()
{
  // print farewell message + currentNickname to LCD
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Take care,");
  lcd.setCursor(0, 1);
  lcd.print(currentNickname);
  delay(2000);

  // print farewell message to serial
  Serial.print(F("\n"));
  Serial.print(currentNickname);
  Serial.println(F("'s parents have arrived to pick them up."));
  Serial.print(F("It's time for "));
  Serial.print(currentNickname);
  Serial.println(F(" to go home."));

  delay(2000);

  lcd.clear();
  // clear serial

  memset(currentNickname, 0, sizeof(currentNickname));
  memset(nicknameInput, 0, sizeof(nicknameInput));
  // clear both arrays

  currentName = "";
  currentSpecies = "";
  job1 = "";
  job2 = "";
  currentTiredness = "";
  currentHunger = "";
  currentThirst = "";
  currentHappiness = "";
  currentTrust = "";

  currentAge = 0;
  speciesIndex = 0;
  griffinNameIndex = 0;
  dragonNameIndex = 0;
  phoenixNameIndex = 0;
  trustIndex = 0;
  job1Index = 0;
  job2Index = 0;
  tirednessIndex = 0;
  hungerIndex = 0;
  thirstIndex = 0;
  happinessIndex = 0;
  // clear all values

  isGenerated = false;
  // set to false so generateTraits() can run again when button 1 is pressed
  delay(1000);

  Serial.println(F("Press Button 1 to care for a new creature."));
}

void menuChooseAction()
{
  bool isRefreshedRequired = true;
  // track whether we need to refresh the menu

  while (isGenerated)
  // run until creature has been generated
  {
    if (isRefreshedRequired)
    // if menu refresh is required, print to serial (button options 2-7)
    // if user pressed button 1, it will tell them they're already caring for a creature (i.e. they can't generate a new one)
    {
      delay(500);
      Serial.println();
      Serial.println(F("--- Menu ---"));
      delay(300);
      Serial.print(F("Press Button 2 to have a little dance party with "));
      Serial.print(currentNickname);
      Serial.println(F("."));
      delay(300);
      Serial.print(F("Press Button 3 to give "));
      Serial.print(currentNickname);
      Serial.println(F(" food and water."));
      delay(300);
      Serial.print(F("Press Button 4 to tuck "));
      Serial.print(currentNickname);
      Serial.println(F(" in for a nap."));
      delay(300);
      Serial.print(F("Press Button 5 to give "));
      Serial.print(currentNickname);
      Serial.println(F(" headpats."));
      delay(300);
      Serial.print(F("Press Button 6 to see "));
      Serial.print(currentNickname);
      Serial.println(F("'s current condition."));
      delay(300);
      Serial.print(F("Press Button 7 when it's time for "));
      Serial.print(currentNickname);
      Serial.println(F("'s parents to pick them up."));
      // put creature's pickup time in the user's hands, so they can decide when they'd like to generate a new creature to care for

      isRefreshedRequired = false; // set to false so menu options don't print again
    }

    for (int i = 0; i < 10; i++)
    {
      // use a loop to keep checking for button inputs
      // trigger relevant function on button input
      if (digitalRead(button1) == HIGH)
      {
        Serial.print("\n");
        Serial.print(F("You're already caring for "));
        Serial.print(currentNickname);
        Serial.println(".");
        isRefreshedRequired = true;
        // each time a button is pressed, set this to true, so the menu options will print again
        break;
      }
      if (digitalRead(button2) == HIGH)
      {
        delay(50);
        danceParty();
        isRefreshedRequired = true;
        break;
      }
      if (digitalRead(button3) == HIGH)
      {
        delay(50);
        foodAndWater();
        isRefreshedRequired = true;
        break;
      }
      if (digitalRead(button4) == HIGH)
      {
        delay(50);
        nap();
        isRefreshedRequired = true;
        break;
      }
      if (digitalRead(button5) == HIGH)
      {
        delay(50);
        headpats();
        isRefreshedRequired = true;
        break;
      }
      if (digitalRead(button6) == HIGH)
      {
        delay(50);
        displayCurrentCondition();
        isRefreshedRequired = true;
        break;
      }
      if (digitalRead(button7) == HIGH)
      {
        delay(50);
        parentsPickup();
        isRefreshedRequired = true;
        break;
      }
      delay(100);
    }
  }
}

// - setup and loop - //

void setup()
{
  Serial.begin(9600);
  // initialize serial
  randomSeed(analogRead(0));
  // for random values
  Serial.print(F("Press Button 1 to begin."));
  // welcome message on serial

  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Creature Care");
  // display organization name on the LCD

  // intialize all pins; RGB to output, everything else to input
  pinMode(button1, INPUT);
  pinMode(button2, INPUT);
  pinMode(button3, INPUT);
  pinMode(button4, INPUT);
  pinMode(button5, INPUT);
  pinMode(button6, INPUT);
  pinMode(button7, INPUT);
  pinMode(RGBBluePin, OUTPUT);
  pinMode(RGBGreenPin, OUTPUT);
  pinMode(RGBRedPin, OUTPUT);
}

void loop()
{
  if (!isGenerated)
  // while a creature hasn't been generated, call generatetraits()
  {
    generateTraits();
  }
  else
  // once a creature is generated, call menuChooseAction()
  {
    menuChooseAction();
  }
  delay(50);
}